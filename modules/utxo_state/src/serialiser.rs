//! Acropolis UTXO state - serialiser
//! Takes potentially out-of-order UTXO delta messages and reorders them
//! before presenting to the state

use std::collections::BinaryHeap;
use std::cmp::Ordering;
use tracing::{debug, info, error};

use acropolis_messages::{BlockInfo, BlockStatus, UTXODelta, UTXODeltasMessage};
use crate::state::State;

/// Pending queue entry
struct PendingEntry {
    /// Block number
    number: u64,

    /// Deltas message
    message: UTXODeltasMessage,
}

// Ord and Eq implementations to make it a min-heap on block number
impl Ord for PendingEntry {
    fn cmp(&self, other: &Self) -> Ordering {
        other.number.cmp(&self.number)  // Note reverse order
    }
}

impl PartialOrd for PendingEntry {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl Eq for PendingEntry {}

impl PartialEq for PendingEntry {
    fn eq(&self, other: &Self) -> bool {
        self.number == other.number
    }
}

/// UTXO delta serialiser
pub struct Serialiser {
    /// UTXO state
    state: State,

    /// Pending queue, presents messages in order, implemented as a reversed max-heap
    pending: BinaryHeap<PendingEntry>,

    /// Last block number received (if any)
    last_block_number: Option<u64>,
}

impl Serialiser {
    /// Constructor
    pub fn new() -> Self {
        Self {
            state: State::new(),
            pending: BinaryHeap::new(),
            last_block_number: None,
        }
    }

    /// Check whether a block is in order
    fn is_in_order(&self, block: &BlockInfo) -> bool {

        match self.last_block_number {
            Some(last_number) => {
                match block.status {
                    BlockStatus::RolledBack => {
                        // Check if we can process it yet - only if it is behind our current tip
                        // If it replaces our tip (the most common occurrence), that's fine
                        // It it's actually the next block (as happens in the handover between Mithril
                        // upstream chain fetch), that's OK too.
                        if block.number > last_number+1 {
                            return false;
                        }
                    }

                    // Normal arrival, genesis, immutable, volatile
                    _ => {
                        // Double check we don't see rewinds or duplicates, except block 0
                        // which is generated by genesis and chain
                        if block.number <= last_number && block.number != 0 {
                            error!("Block {} received expecting {} - ignored!",
                                block.number, last_number+1);
                            return true;  // Pretend we processed it
                        }

                        // They must arrive in order at this point
                        if block.number != last_number + 1 && block.number != 0 {
                            return false;
                        }
                    }
                }
            }

            // First time only accept 0
            _ => return block.number == 0
        }

        return true;    
    }

    /// Process a message
    fn process_message(&mut self, deltas: &UTXODeltasMessage) {
        let number = deltas.block.number;

        // Observe block for stats and rollbacks, checking it is in order
        self.state.observe_block(&deltas.block);

        // Process the deltas
        for delta in &deltas.deltas {  // UTXODelta

            match delta {
                UTXODelta::Input(tx_input) => {
                    self.state.observe_input(&tx_input, number);
                }, 

                UTXODelta::Output(tx_output) => {
                    self.state.observe_output(&tx_output, number);
                },

                _ => {}
            }
        }

        // Update sequence - but note we get two block 0 from genesis
        // and chain itself (this is ugly!)
        if self.last_block_number.is_none() || number != 0 {
            self.last_block_number = Some(number);
        }
    }

    /// Handle a UTXO delta message
    pub fn observe_utxo_deltas(&mut self, deltas: &UTXODeltasMessage) {

        // Is it in order?
        if self.is_in_order(&deltas.block) {

            self.process_message(&deltas);

            // See if any pending now work
            while let Some(next_pending) = self.pending.peek() {
                if self.is_in_order(&next_pending.message.block) {

                    if tracing::enabled!(tracing::Level::DEBUG) {
                        debug!("Now accepted block {}", next_pending.number);
                    }

                    // We have to clone to avoid mut borrow of self when we obtained
                    // next_pending by immut borrow in peek() - not pleasant!
                    self.process_message(&next_pending.message.clone());
                    self.pending.pop();
                } else {
                    break;
                }
            }
        } else {
            // Not accepted, it's out of order, queue it
            if tracing::enabled!(tracing::Level::DEBUG) {
                debug!("Queueing out-of-order block {}", deltas.block.number);
            }
            self.pending.push(PendingEntry {
                number: deltas.block.number,
                message: deltas.clone()
            });
        }
    }

    /// Periodic tick for background logging and pruning
    pub fn tick(&mut self) {
        self.state.prune();
        self.state.log_stats();
        if self.pending.len() != 0 {
            info!(pending = self.pending.len());
        }
    }
}

