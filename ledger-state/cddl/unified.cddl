; This file contains some some basic, shared types that are used throughout the ledger state specification.

hash_28 = bytes .size 28
hash_32 = bytes .size 32

keyhash = hash_28

; TODO: Are able to further restrict the legal bytes of reward account according to CIP-19 (https://cips.cardano.org/cip/CIP-19)?
reward_account = bytes

credential = [(0, addr_keyhash) // (1, script_hash)]


positive_coin = 1 .. maxWord64
maxWord64 = 18446744073709551615

coin = uint
epoch = uint .size 8

gov_action_id = [hash_32, uint .size 2]


; Unfortunately, CDDL does not provide ways that we can restrict the content of a bytestring.
; As a result, we are unable to define addresses in a restrictive way that is machine readable
; In theory, we could provide custom decorators to convert `text` to `bytes`, then
; the .regexp control operator to more accurately define the addresses.
; For more restrictive information regarding the address, check the Conway era CDDL:
; https://github.com/IntersectMBO/cardano-ledger/blob/master/eras/conway/impl/cddl-files/conway.cddl#L167
address = bytes

denominator = uint .gt 0
; A unit interval is a rational number (https://peteroupc.github.io/CBOR/rational.html)
; that MUST be in the range [0, 1].
;
; The additional restriction requires that:
;   numerator <= denominator
;
; This relation cannot be expressed in CDDL (TODO: is this true?)
; but it must be enforced by serialization/deserialization processes
unit_interval = #6.30([uint, uint])

; Conway introduced `nonempty_set` as:
;   `nonempty_set<a0> = #6.258([+ a0])/ [+ a0]`
; For simplicity, we remove the option, and require the tag 258.
nonempty_set<T> = #6.258([+ T])

url = text .size (0 .. 128)

; This file defines the specification for the UTxO state. It is based on the `UtxOState` definition from the cardano-ledger specification.

; Cardano Types
datum_option = [(0, hash_32) // (1, data)]
data = #6.24(bytes .cbor plutus_data)
script_ref = #6.24(bytes .cbor script)

plutus_data =
  constr<plutus_data>
  / {* plutus_data => plutus_data}
  / [* plutus_data]
  / big_int
  / bounded_bytes

constr<T> =
  #6.121([* T])
  / #6.122([* T])
  / #6.123([* T])
  / #6.124([* T])
  / #6.125([* T])
  / #6.126([* T])
  / #6.127([* T])
  / #6.102([uint, [* T]])

; The real bounded_bytes does not have this limit. it instead has
; a different limit which cannot be expressed in CDDL.
;
; The limit is as follows:
;  - bytes with a definite-length encoding are limited to size 0..64
;  - for bytes with an indefinite-length CBOR encoding, each chunk is
;    limited to size 0..64
;  ( reminder: in CBOR, the indefinite-length encoding of
;  bytestrings consists of a token #2.31 followed by a sequence
;  of definite-length encoded bytestrings and a stop code )
bounded_bytes = bytes .size (0 .. 64)
big_int = int / big_uint / big_nint
big_uint = #6.2(bounded_bytes)

multiasset<T> = {+
    hash28 => {+
        bytes .size (0 .. 32) =>
        T
    } ; @name MULTI_ASSET_NAME
}
value = coin / [coin, multiasset<positive_coin>]

tx_in = [hash_32, uint .size 2]

shelley_tx_out = [address, value, ? hash_32]
babbage_tx_out = {
    0 : address ; @name ADDRESS
  , 1 : value ; @name VALUE
  , ? 2 : datum_option ; @name DATUM_OPTION
  , ? 3 : script_ref ; @name SCRIPT_REF
  }

tx_out = shelley_tx_out / babbage_tx_out

; `utxo_state` provides the current UTxO set and tracks value leaving the UTxO set at the next epoch boundary
utxo_state = {
    utxos   : { * tx_in => tx_out }
  , fees    : coin
  , deposits: { * deposit => coin }
  , dontions: coin
}

deposit = credential_deposit
  / pool_deposit
  / drep_deposit
  / gov_action_deposit

credential_deposit = (0, credential)
pool_deposit = (1, keyhash)
drep_deposit = (2, credential)
gov_action_deposit = (3, gov_action_id)

; This file defines the specification for the SPO State. It is based on the `PState` definition from the cardano-ledger specification.

; `spo_state` provides the current state of active pools, and at which epochs upcoming pool retirements will occur
spo_state = {
    pools    : { * keyhash => pool_parameters }
  , retiring : { * keyhash => epoch }
}

pool_parameters = (
    operator       : keyhash
  , vrf_keyhash    : hash_32
  , pledge         : coin
  , cost           : coin
  , margin         : unit_interval
  , reward_account : reward_account
  , pool_owners    : nonempty_set<keyhash>
  , relays         : [* relay]
  , pool_metadata  : pool_metadata / nil
  )


relay = [single_host_addr // single_host_name // multi_host_name]

single_host_addr = (0, port / nil, ipv4 / nil, ipv6 / nil)

port = uint .le 65535
ipv4 = bytes .size 4
ipv6 = bytes .size 16

; dns_name: An A or AAAA DNS record
single_host_name = (1, port / nil, dns_name)
dns_name = text .size (0 .. 128)

; dns_name: An SRV DNS record
multi_host_name = (2, dns_name)

pool_metadata = [url, bytes]
