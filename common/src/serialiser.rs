//! Acropolis common library - message serialiser
//! Serialises messages based on block number

use std::collections::BinaryHeap;
use std::cmp::Ordering;
use tracing::{debug, info, error};
use std::sync::{Arc, Mutex};

use acropolis_messages::{BlockStatus, BlockInfo};
use caryatid_sdk::MessageBounds;

/// Pending queue entry
struct PendingEntry<MSG: MessageBounds> {
    /// Block information
    block: BlockInfo,

    /// Message
    message: MSG,
}

// Ord and Eq implementations to make it a min-heap on block number
impl<MSG: MessageBounds> Ord for PendingEntry<MSG> {
    fn cmp(&self, other: &Self) -> Ordering {
        other.block.number.cmp(&self.block.number)  // Note reverse order
    }
}

impl<MSG: MessageBounds> PartialOrd for PendingEntry<MSG> {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl<MSG: MessageBounds> Eq for PendingEntry<MSG> {}

impl<MSG: MessageBounds> PartialEq for PendingEntry<MSG> {
    fn eq(&self, other: &Self) -> bool {
        self.block.number == other.block.number
    }
}

/// Message handler (once serialised)
pub trait SerialisedMessageHandler<MSG: MessageBounds>: Send + Sync {

    /// Handle a message
    fn handle(&mut self, message: &MSG);
}

/// Message serialiser
pub struct Serialiser<MSG: MessageBounds> {
    /// Pending queue, presents messages in order, implemented as a reversed max-heap
    pending: BinaryHeap<PendingEntry<MSG>>,

    /// Last block number received (if any)
    last_block_number: Option<u64>,

    /// Message handler
    handler: Arc<Mutex<dyn SerialisedMessageHandler<MSG>>>,
}

impl <MSG: MessageBounds> Serialiser<MSG> {
    /// Constructor
    pub fn new(handler: Arc<Mutex<dyn SerialisedMessageHandler<MSG>>>) -> Self {
        Self {
            pending: BinaryHeap::new(),
            last_block_number: None,
            handler,
        }
    }

    /// Check whether a block is in order
    fn is_in_order(&self, block: &BlockInfo) -> bool {

        match self.last_block_number {
            Some(last_number) => {
                match block.status {
                    BlockStatus::RolledBack => {
                        // Check if we can process it yet - only if it is behind our current tip
                        // If it replaces our tip (the most common occurrence), that's fine
                        // It it's actually the next block (as happens in the handover between Mithril
                        // upstream chain fetch), that's OK too.
                        if block.number > last_number+1 {
                            return false;
                        }
                    }

                    // Normal arrival, genesis, immutable, volatile
                    _ => {
                        // Double check we don't see rewinds or duplicates, except block 0
                        // which is generated by genesis and chain
                        if block.number <= last_number && block.number != 0 {
                            error!("Block {} received expecting {}!",
                                block.number, last_number+1);
                            return true;  // Allow processing it
                        }

                        // They must arrive in order at this point
                        if block.number != last_number + 1 && block.number != 0 {
                            return false;
                        }
                    }
                }
            }

            // First time only accept 0
            _ => return block.number == 0
        }

        return true;    
    }

    /// Process a message
    fn process_message(&mut self, block: &BlockInfo, message: &MSG) {
        let number = block.number;

        // Pass to the handler
        self.handler.lock().unwrap().handle(message);

        // Update sequence - but note we get two block 0 from genesis
        // and chain itself (this is ugly!)
        if self.last_block_number.is_none() || number != 0 {
            self.last_block_number = Some(number);
        }
    }

    /// Handle a message
    pub fn handle_message(&mut self, block: &BlockInfo, message: &MSG) {

        // Is it in order?
        if self.is_in_order(&block) {

            self.process_message(&block, &message);

            // See if any pending now work
            while let Some(next) = self.pending.peek() {
                if self.is_in_order(&next.block) {

                    if tracing::enabled!(tracing::Level::DEBUG) {
                        debug!("Now accepted block {}", next.block.number);
                    }

                    if let Some(next) = self.pending.pop() {
                        self.process_message(&next.block, &next.message);
                    }
                } else {
                    break;
                }
            }
        } else {
            // Not accepted, it's out of order, queue it
            if tracing::enabled!(tracing::Level::DEBUG) {
                debug!("Queueing out-of-order block {}", block.number);
            }
            self.pending.push(PendingEntry {
                block: block.clone(),
                message: message.clone(),
            });
        }
    }

    /// Periodic tick for background logging
    pub fn tick(&mut self) {
        if self.pending.len() != 0 {
            info!(pending = self.pending.len());
        }
    }
}

// -- Tests --
#[cfg(test)]
mod tests {
    use super::*;

    // Mock message handler to track received messages
    struct MockMessageHandler {
        received: Vec<u64>,
    }

    impl MockMessageHandler {
        pub fn new() -> Self {
            Self {
                received: Vec::new()
            }
        }
    }

    // Test message
    #[derive(Debug, Default, Clone, serde::Serialize, serde::Deserialize)]
    pub struct TestMessage {
        /// Block info
        pub block: BlockInfo,
    }

    impl SerialisedMessageHandler<TestMessage> for MockMessageHandler {
        fn handle(&mut self, message: &TestMessage) {
            self.received.push(message.block.number);
        }
    }

    // Simple in-order test
    #[test]
    fn messages_in_order_pass_through() {
        let handler = Arc::new(Mutex::new(MockMessageHandler::new()));
        let handler2 = handler.clone();
        let mut serialiser = Serialiser::new(handler);

        let message1 = TestMessage {
            block: BlockInfo {
                status: BlockStatus::Immutable,
                number: 0,
                slot: 0,
                hash: Vec::new()
            }
        };
        serialiser.handle_message(&message1.block, &message1);

        let message2 = TestMessage {
            block: BlockInfo {
                status: BlockStatus::Immutable,
                number: 1,
                slot: 1,
                hash: Vec::new()
            }
        };
        serialiser.handle_message(&message2.block, &message2);

        let handler = handler2.lock().unwrap();
        assert_eq!(2, handler.received.len());
        assert_eq!(0, handler.received[0]);
        assert_eq!(1, handler.received[1]);
    }

    // Simple out-of-order test
    #[test]
    fn messages_out_of_order_are_reordered() {
        let handler = Arc::new(Mutex::new(MockMessageHandler::new()));
        let handler2 = handler.clone();
        let mut serialiser = Serialiser::new(handler);

        let message1 = TestMessage {
            block: BlockInfo {
                status: BlockStatus::Immutable,
                number: 1,
                slot: 1,
                hash: Vec::new()
            }
        };
        serialiser.handle_message(&message1.block, &message1);

        let message2 = TestMessage {
            block: BlockInfo {
                status: BlockStatus::Immutable,
                number: 0,
                slot: 0,
                hash: Vec::new()
            }
        };
        serialiser.handle_message(&message2.block, &message2);

        let handler = handler2.lock().unwrap();
        assert_eq!(2, handler.received.len());
        assert_eq!(0, handler.received[0]);
        assert_eq!(1, handler.received[1]);
    }

    // Rollback in-order test
    #[test]
    fn rollback_in_order_is_passed_through() {
        let handler = Arc::new(Mutex::new(MockMessageHandler::new()));
        let handler2 = handler.clone();
        let mut serialiser = Serialiser::new(handler);

        let message1 = TestMessage {
            block: BlockInfo {
                status: BlockStatus::Volatile,
                number: 0,
                slot: 0,
                hash: Vec::new()
            }
        };
        serialiser.handle_message(&message1.block, &message1);

        let message2 = TestMessage {
            block: BlockInfo {
                status: BlockStatus::Volatile,
                number: 1,
                slot: 1,
                hash: Vec::new()
            }
        };
        serialiser.handle_message(&message2.block, &message2);

        let message3 = TestMessage {
            block: BlockInfo {
                status: BlockStatus::RolledBack,
                number: 1,
                slot: 1,
                hash: Vec::new()
            }
        };
        serialiser.handle_message(&message3.block, &message3);

        let handler = handler2.lock().unwrap();
        assert_eq!(3, handler.received.len());
        assert_eq!(0, handler.received[0]);
        assert_eq!(1, handler.received[1]);
        assert_eq!(1, handler.received[1]);
    }

    // Rollback out-of-order test
    #[test]
    fn rollback_out_of_order_is_reordered() {
        let handler = Arc::new(Mutex::new(MockMessageHandler::new()));
        let handler2 = handler.clone();
        let mut serialiser = Serialiser::new(handler);

        let message1 = TestMessage {
            block: BlockInfo {
                status: BlockStatus::Volatile,
                number: 1,
                slot: 1,
                hash: Vec::new()
            }
        };
        serialiser.handle_message(&message1.block, &message1);

        let message2 = TestMessage {
            block: BlockInfo {
                status: BlockStatus::RolledBack,
                number: 1,
                slot: 1,
                hash: Vec::new()
            }
        };
        serialiser.handle_message(&message2.block, &message2);

        let message3 = TestMessage {
            block: BlockInfo {
                status: BlockStatus::Volatile,
                number: 0,
                slot: 0,
                hash: Vec::new()
            }
        };
        serialiser.handle_message(&message3.block, &message3);


        let handler = handler2.lock().unwrap();
        assert_eq!(3, handler.received.len());
        assert_eq!(0, handler.received[0]);
        assert_eq!(1, handler.received[1]);
        assert_eq!(1, handler.received[1]);
    }
}
